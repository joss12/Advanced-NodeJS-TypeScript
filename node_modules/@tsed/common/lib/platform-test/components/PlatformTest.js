"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformTest = void 0;
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const platform_builder_1 = require("../../platform-builder");
const ServerLoader_1 = require("../../platform-express/components/ServerLoader");
const PlatformContext_1 = require("../../platform/domain/PlatformContext");
const PlatformApplication_1 = require("../../platform/services/PlatformApplication");
/**
 * @platform
 */
class PlatformTest {
    static get injector() {
        if (this._injector) {
            return this._injector;
        }
        /* istanbul ignore next */
        throw new Error("PlatformTest.injector is not initialized. Use PlatformTest.create(): Promise before PlatformTest.invoke() or PlatformTest.injector.\n" +
            "Example:\n" +
            "before(async () => {\n" +
            "   await PlatformTest.create()\n" +
            "   await PlatformTest.invoke(MyService, [])\n" +
            "})");
    }
    static async create(options = {}) {
        PlatformTest._injector = PlatformTest.createInjector(options);
        await platform_builder_1.loadInjector(PlatformTest._injector);
    }
    /**
     * Create a new injector with the right default services
     */
    static createInjector(options = {}) {
        const injector = platform_builder_1.createInjector(options);
        injector.settings.env = core_1.Env.TEST;
        return injector;
    }
    /**
     * Load the server silently without listening port and configure it on test profile.
     * @decorator
     * @param mod
     * @param options
     * @returns {Promise<void>}
     */
    static bootstrap(mod, options = {}) {
        return async function before() {
            let instance;
            if (core_1.isInheritedFrom(mod, ServerLoader_1.ServerLoader)) {
                instance = await ServerLoader_1.ServerLoader.bootstrap(mod, {
                    logger: {
                        level: "off",
                        ...(options.logger || {})
                    },
                    ...options
                });
            }
            else {
                PlatformTest.platformBuilder = options.platform || PlatformTest.platformBuilder;
                /* istanbul ignore next */
                if (!PlatformTest.platformBuilder) {
                    throw new Error("Platform type is not specified. Have you added at least `import @tsed/platform-express` (or equivalent) on your Server.ts ?");
                }
                // @ts-ignore
                instance = await platform_builder_1.PlatformBuilder.build(PlatformTest.platformBuilder).bootstrap(mod, {
                    logger: {
                        level: "off",
                        ...(options.logger || {})
                    },
                    ...options
                });
            }
            await instance.callHook("$beforeListen");
            await instance.callHook("$afterListen");
            await instance.ready();
            // used by inject method
            PlatformTest._injector = instance.injector;
        };
    }
    /**
     * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.
     */
    static async reset() {
        if (PlatformTest._injector) {
            await PlatformTest._injector.destroy();
            PlatformTest._injector = null;
        }
    }
    /**
     * It injects services into the test function where you can alter, spy on, and manipulate them.
     *
     * The inject function has two parameters
     *
     * * an array of Service dependency injection tokens,
     * * a test function whose parameters correspond exactly to each item in the injection token array.
     *
     * @param targets
     * @param func
     */
    static inject(targets, func) {
        return async () => {
            if (!PlatformTest._injector) {
                await PlatformTest.create();
            }
            const injector = PlatformTest.injector;
            const deps = [];
            for (const target of targets) {
                deps.push(injector.has(target) ? injector.get(target) : await injector.invoke(target));
            }
            return await func(...deps);
        };
    }
    /**
     * Invoke a provider and return a fresh instance
     * @param target
     * @param providers
     */
    static invoke(target, providers = []) {
        const locals = new di_1.LocalsContainer();
        providers.forEach((p) => {
            locals.set(p.token, p.use);
        });
        const instance = PlatformTest.injector.invoke(target, locals, { rebuild: true });
        if (instance && instance.$onInit) {
            // await instance.$onInit();
            const result = instance.$onInit();
            if (result instanceof Promise) {
                return result.then(() => instance);
            }
        }
        return instance;
    }
    /**
     * Return the instance from injector registry
     * @param target
     * @param options
     */
    static get(target, options = {}) {
        return PlatformTest.injector.get(target, options);
    }
    /**
     * Return the raw application (express or koa).
     * Use this callback with SuperTest.
     *
     * ```typescript
     * let request: SuperTest.SuperTest<SuperTest.Test>;
     * beforeEach(PlatformTest.bootstrap(Server, {
     *   mount: {
     *     "/rest": [ProductsController]
     *   }
     * }));
     * beforeEach(() => {
     *   request = SuperTest(PlatformTest.callback());
     * });
     * ```
     */
    static callback() {
        var _a;
        return (_a = PlatformTest.injector.get(PlatformApplication_1.PlatformApplication)) === null || _a === void 0 ? void 0 : _a.callback();
    }
    static createRequestContext(options = {}) {
        return new PlatformContext_1.PlatformContext({
            id: "id",
            logger: this.injector.logger,
            url: "/",
            ...options
        });
    }
}
exports.PlatformTest = PlatformTest;
PlatformTest._injector = null;
//# sourceMappingURL=PlatformTest.js.map