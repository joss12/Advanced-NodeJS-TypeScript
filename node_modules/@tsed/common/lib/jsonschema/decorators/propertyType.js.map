{"version":3,"file":"propertyType.js","sourceRoot":"","sources":["../../../src/jsonschema/decorators/propertyType.ts"],"names":[],"mappings":";;;AAEA,yCAAsC;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmDG;AACH,SAAgB,YAAY,CAAC,IAAe;IAC1C,OAAO,qBAAU,CAAC,CAAC,gBAAkC,EAAE,EAAE;QACvD,gBAAgB,CAAC,IAAI,GAAG,IAAI,CAAC;IAC/B,CAAC,CAAC,CAAC;AACL,CAAC;AAJD,oCAIC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+CG;AACH,SAAgB,YAAY,CAAC,IAAe;IAC1C,OAAO,YAAY,CAAC,IAAI,CAAC,CAAC;AAC5B,CAAC;AAFD,oCAEC","sourcesContent":["import {Type} from \"@tsed/core\";\nimport {PropertyMetadata} from \"../../mvc/models/PropertyMetadata\";\nimport {PropertyFn} from \"./property\";\n\n/**\n * Set the type of the array items. The possible value is String, Boolean, Number, Date, Object, Class, etc...\n *\n * ::: warning\n * This decorator will be removed in v6 in favor of @@CollectionOf@@ from @tsed/schema.\n * For v5 user, use @@CollectionOf@@ decorator from @tsed/common then in v6 switch to @tsed/schema.\n * :::\n *\n * ::: tip\n * This decorator is used by the Converters to correctly deserialize your model.\n * :::\n *\n * ```typescript\n * class Model {\n *    @CollectionOf(String)\n *    property: string[];\n * }\n * ```\n * ::: warning\n * Don't use `type Type = string | number` as Type parameter.\n * :::\n *\n * The following code doesn't work:\n *\n * ```typescript\n * type Type = \"string\" | \"number\"\n * class Model {\n *    @CollectionOf(Type)\n *    property: Type[];\n * }\n * ```\n *\n * Instead, this code works with converter and AJV:\n *\n * ```typescript\n * type Type = \"string\" | \"number\"\n * class Model {\n *    @Property()\n *    @AllowTypes(\"string\", \"number\") // for AJV\n *    property: Type[];\n * }\n * ```\n *\n * @param {Type<any>} type\n * @returns {Function}\n * @decorator\n * @jsonMapper\n * @schema\n * @property\n * @collections\n * @deprecated Use CollectionOf instead. Will be removed in v6.\n */\nexport function PropertyType(type: Type<any>) {\n  return PropertyFn((propertyMetadata: PropertyMetadata) => {\n    propertyMetadata.type = type;\n  });\n}\n\n/**\n * Set the type of the array items. The possible value is String, Boolean, Number, Date, Object, Class, etc...\n *\n * ::: tip\n * This decorator is used by the Converters to correctly deserialize your model.\n * :::\n *\n * ```typescript\n * class Model {\n *    @CollectionOf(String)\n *    property: string[];\n * }\n * ```\n * ::: warning\n * Don't use `type Type = string | number` as Type parameter.\n * :::\n *\n * The following code doesn't work:\n *\n * ```typescript\n * type Type = \"string\" | \"number\"\n * class Model {\n *    @CollectionOf(Type)\n *    property: Type[];\n * }\n * ```\n *\n * Instead, this code works with converter and AJV:\n *\n * ```typescript\n * type Type = \"string\" | \"number\"\n * class Model {\n *    @Property()\n *    @AllowTypes(\"string\", \"number\") // for AJV\n *    property: Type[];\n * }\n * ```\n *\n * @param {Type<any>} type\n * @returns {Function}\n * @decorator\n * @validation\n * @jsonMapper\n * @schema\n * @property\n * @collections\n * @alias PropertyType\n */\nexport function CollectionOf(type: Type<any>) {\n  return PropertyType(type);\n}\n"]}