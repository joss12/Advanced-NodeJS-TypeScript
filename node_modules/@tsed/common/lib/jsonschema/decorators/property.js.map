{"version":3,"file":"property.js","sourceRoot":"","sources":["../../../src/jsonschema/decorators/property.ts"],"names":[],"mappings":";;;;AAAA,qCAAwD;AACxD,6BAA6B;AAG7B,6CAAwC;AAExC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsFG;AACH,uBAAuB;AACvB,SAAgB,YAAY,CAAC,OAAmC;IAC9D,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,gCAAgC,CAAC,CAAC;AAC7E,CAAC;AAFD,oCAEC;AA6FD,SAAgB,QAAQ,CAAC,OAAa;IACpC,OAAO,uBAAU,CAAC,CAAC,gBAAkC,EAAE,EAAE;QACvD,0BAA0B;QAC1B,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YAC/B,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,GAAE,CAAC,EAAE,6DAA6D,CAAC,EAAE,CAAC;YAC1F,gBAAgB,CAAC,IAAI,GAAG,OAAiB,CAAC;SAC3C;aAAM,IAAI,OAAO,IAAI,CAAC,oBAAa,CAAC,OAAO,CAAC,EAAE;YAC7C,gBAAgB,CAAC,IAAI,GAAG,OAAc,CAAC;SACxC;aAAM,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YACtC,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,GAAE,CAAC,EAAE,8EAA8E,CAAC,EAAE,CAAC;YAC3G,gBAAgB,CAAC,IAAI,GAAG,OAAO,CAAC,IAAc,CAAC;YAE/C,IAAI,CAAC,cAAO,CAAE,OAA4B,CAAC,GAAG,CAAC,EAAE;gBAC/C,gBAAgB,CAAC,IAAI,GAAI,OAA4B,CAAC,GAAgB,CAAC;aACxE;SACF;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAjBD,4BAiBC;AAED,uDAA6B","sourcesContent":["import {isEmpty, isPlainObject, Type} from \"@tsed/core\";\nimport * as util from \"util\";\nimport {IPropertyOptions} from \"../../converters/interfaces/IPropertyOptions\";\nimport {PropertyMetadata} from \"../../mvc/models/PropertyMetadata\";\nimport {PropertyFn} from \"./propertyFn\";\n\n/**\n * `@Property()` let you decorate an attribute that can be serialized or deserialized. By default, no parameters are required to use it.\n * But in some cases, we need to configure explicitly the JSON attribute name mapped to the provide attribute.\n *\n * Here an example of different use cases with `@Property()`:\n *\n * ```typescript\n * class EventModel {\n *    @Property()\n *    name: string;\n *\n *    @Format('date-time')\n *    startDate: Date;\n *\n *    @Name('end-date')\n *    @Format('date-time')\n *    endDate: Date;\n *\n *    @CollectionOf(Task)\n *    tasks: TaskModel[];\n * }\n *\n * class TaskModel {\n *     @Property()\n *     subject: string;\n *\n *     @Minimum(0)  // Property or Property is not required when a JsonSchema decorator is used\n *     @Maximum(100)\n *     rate: number;\n * }\n *\n * > Theses ES6 collections can be used: Map and Set. Map will be serialized as an object and Set as an array.\n * By default Date, Array, Map and Set have a default custom Converter already embed. But you can override theses (see next part).\n *\n * For the Array, you must use the @@CollectionOf@@ decorator.\n * `TypeClass` will be used to deserialize each item in the collection stored on the attribute source.\n *\n * According to the previous example, the JsonSchema generated will be as follow:\n *\n * ```typescript\n * {\n *    \"type\": \"object\",\n *    \"properties\": {\n *       \"name\": {\n *          \"type\": \"string\"\n *       },\n *       \"startDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"endDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"tasks\": {\n *          \"type\": \"array\",\n *          \"items\": {\n *             \"$ref\": \"#/definitions/Task\"\n *          }\n *       }\n *    },\n *    \"definitions\": {\n *      \"Task\": {\n *        \"type\": \"object\",\n *        \"properties\": {\n *          \"subject\": {\n *             \"type\": \"string\",\n *          },\n *          \"rate\": {\n *             \"type\": \"number\"\n *             \"minimum\": 0,\n *             \"maximum: 100\n *          }\n *        }\n *      }\n *    }\n * }\n * ```\n *\n * @returns {Function}\n * @param options\n * @decorator\n * @validation\n * @swagger\n * @schema\n * @deprecated Use Property decorator instead\n */\n// istanbul ignore next\nexport function JsonProperty(options?: IPropertyOptions | string): Function {\n  return util.deprecate(Property(options), \"Use property decorator instead\");\n}\n\n/**\n * `@Property()` let you decorate an attribute that can be serialized or deserialized. By default, no parameters are required to use it.\n * But in some cases, we need to configure explicitly the JSON attribute name mapped to the provide attribute.\n *\n * Here an example of different use cases with `@Property()`:\n *\n * ```typescript\n * class EventModel {\n *\n *    @Property()\n *    name: string;\n *\n *    @Property()\n *    @Format('date-time')\n *    startDate: Date;\n *\n *    @Name('end-date')\n *    @Format('date-time')\n *    endDate: Date;\n *\n *    @CollectionOf(Task)\n *    tasks: TaskModel[];\n * }\n *\n * class TaskModel {\n *     @Property()\n *     subject: string;\n *\n *     @Minimum(0)  // Property or Property is not required when a JsonSchema decorator is used\n *     @Maximum(100)\n *     rate: number;\n * }\n *\n * > Theses ES6 collections can be used: Map and Set. Map will be serialized as an object and Set as an array.\n * By default Date, Array, Map and Set have a default custom Converter already embed. But you can override theses (see next part).\n *\n * For the Array, you must use the @@CollectionOf@@ decorator.\n * `TypeClass` will be used to deserialize each item in the collection stored on the attribute source.\n *\n * According to the previous example, the JsonSchema generated will be as follow:\n *\n * ```typescript\n * {\n *    \"type\": \"object\",\n *    \"properties\": {\n *       \"name\": {\n *          \"type\": \"string\"\n *       },\n *       \"startDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"endDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"tasks\": {\n *          \"type\": \"array\",\n *          \"items\": {\n *             \"$ref\": \"#/definitions/Task\"\n *          }\n *       }\n *    },\n *    \"definitions\": {\n *      \"Task\": {\n *        \"type\": \"object\",\n *        \"properties\": {\n *          \"subject\": {\n *             \"type\": \"string\",\n *          },\n *          \"rate\": {\n *             \"type\": \"number\"\n *             \"minimum\": 0,\n *             \"maximum: 100\n *          }\n *        }\n *      }\n *    }\n * }\n * ```\n *\n * @returns {Function}\n * @decorator\n * @validation\n * @swagger\n * @schema\n */\nexport function Property(): PropertyDecorator;\nexport function Property(type: Type<any>): PropertyDecorator;\nexport function Property(options?: IPropertyOptions | string | Type<any>): PropertyDecorator;\nexport function Property(name: string): PropertyDecorator;\nexport function Property(options?: any): Function {\n  return PropertyFn((propertyMetadata: PropertyMetadata) => {\n    /* istanbul ignore next */\n    if (typeof options === \"string\") {\n      util.deprecate(() => {}, \"@Property(name: string) are deprecated. Use @Name() instead\")();\n      propertyMetadata.name = options as string;\n    } else if (options && !isPlainObject(options)) {\n      propertyMetadata.type = options as any;\n    } else if (typeof options === \"object\") {\n      util.deprecate(() => {}, \"@Property(options) is deprecated. Use @Name() or/and @CollectionOf() instead\")();\n      propertyMetadata.name = options.name as string;\n\n      if (!isEmpty((options as IPropertyOptions).use)) {\n        propertyMetadata.type = (options as IPropertyOptions).use as Type<any>;\n      }\n    }\n  });\n}\n\nexport * from \"./propertyFn\";\n"]}