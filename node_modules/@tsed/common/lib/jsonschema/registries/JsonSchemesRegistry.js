"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSchemesRegistry = exports.JsonSchemaRegistry = void 0;
const core_1 = require("@tsed/core");
const JsonSchema_1 = require("../class/JsonSchema");
const getJsonType_1 = require("../utils/getJsonType");
const JSON_SCHEMA_FIELDS = ["additionalItems", "items", "additionalProperties", "properties", "dependencies", "oneOf"];
const toObj = (o) => JSON.parse(JSON.stringify(o));
/**
 * Registry to store all schemes.
 *
 * ::: warning
 * This class will be removed in v6
 * :::
 *
 * @deprecated
 */
class JsonSchemaRegistry extends core_1.Registry {
    /**
     *
     * @param schema
     * @param type
     * @param collectionType
     */
    static createJsonSchema(schema = new JsonSchema_1.JsonSchema(), type, collectionType) {
        if (core_1.isClass(type)) {
            schema = Object.keys(schema.toObject()).reduce((newSchema, key) => {
                if (!(key === "type" || key === "items" || key === "additionalProperties")) {
                    newSchema[key] = schema[key];
                }
                return newSchema;
            }, JsonSchema_1.JsonSchema.ref(type));
        }
        else {
            schema.type = type;
        }
        if (collectionType) {
            schema.toCollection(collectionType);
        }
        return schema;
    }
    /**
     *
     * @param {Type<any>} target
     * @param {string} propertyKey
     * @param type
     * @param collectionType
     * @returns {JsonSchema}
     */
    property(target, propertyKey, type, collectionType) {
        if (!this.has(target)) {
            this.merge(target, {
                type: target
            });
            core_1.Store.from(target).set("schema", this.get(target));
        }
        const schema = this.get(target);
        schema.properties = schema.properties || {};
        schema.properties[propertyKey] = JsonSchemaRegistry.createJsonSchema(schema.properties[propertyKey], type, collectionType);
        return schema.properties[propertyKey];
    }
    /**
     *
     * @param target
     * @param {string} propertyKey
     * @param value
     */
    required(target, propertyKey, value) {
        const schema = this.get(target) || {};
        const required = schema.required || [];
        if (value !== undefined) {
            const index = required.indexOf(propertyKey);
            if (value && index === -1) {
                schema.required = [].concat(required, [propertyKey]);
            }
            if (!value && index > -1) {
                required.splice(required.indexOf(propertyKey), 1);
            }
        }
        return (schema.required || []).some((p) => p === propertyKey);
    }
    /**
     *
     * @param {Type<any>} target
     * @param options
     * @returns {JSONSchema6}
     */
    getSchemaDefinition(target, options = {}) {
        if (core_1.isPrimitiveOrPrimitiveClass(target)) {
            return {
                type: getJsonType_1.getJsonType(target)
            };
        }
        return this.getSchema(target, options);
    }
    /**
     *
     * @param {Type<any>} target
     * @param options
     * @returns {JSONSchema6}
     */
    getSchema(target, options = {}) {
        const { definitions = {} } = options;
        const schema = core_1.ancestorsOf(target).reduce((acc, target) => {
            const schema = this.has(target) ? toObj(this.get(target)) : {};
            this.findReferences(schema, { ...options, definitions });
            core_1.deepExtends(acc, schema);
            return acc;
        }, {});
        return { definitions, ...schema };
    }
    /**
     *
     * @param {JsonSchema} schema
     * @param options
     */
    findReferences(schema, options) {
        if (schema.$ref) {
            return this.getRef(schema, options);
        }
        JSON_SCHEMA_FIELDS.forEach((key) => {
            const value = schema[key];
            if (value) {
                if (value.$ref) {
                    return this.getRef(value, options);
                }
                Object.keys(value).forEach((index) => {
                    this.findReferences(value[index], options);
                });
            }
        });
        return schema;
    }
    getRef(schema, options) {
        const name = this.getRefName(schema.$ref);
        if (name && !options.definitions[name]) {
            const [target] = this.getSchemaByName(name) || [];
            if (target) {
                options.definitions[name] = {};
                const { definitions, ...refSchema } = this.getSchema(target, options);
                options.definitions[name] = refSchema;
            }
            else {
                schema.type = "object";
                delete schema.$ref;
            }
        }
        return schema;
    }
    /**
     *
     * @param {string} ref
     * @returns {string}
     */
    getRefName(ref) {
        return (ref || "").replace("#/definitions/", "");
    }
    /**
     *
     * @param {string} name
     * @returns {JsonSchema}
     */
    getSchemaByName(name) {
        return Array.from(this.entries()).find(([, schema]) => schema.refName === name);
    }
}
exports.JsonSchemaRegistry = JsonSchemaRegistry;
/**
 * @deprecated Will be removed in v6.
 */
// tslint:disable-next-line: variable-name
exports.JsonSchemesRegistry = new JsonSchemaRegistry(JsonSchema_1.JsonSchema);
//# sourceMappingURL=JsonSchemesRegistry.js.map