"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyMetadata = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const JsonSchemesRegistry_1 = require("../../jsonschema/registries/JsonSchemesRegistry");
class PropertyMetadata extends core_1.Storable {
    constructor(target, propertyKey) {
        super(target, propertyKey);
        /**
         * Allowed value when the entity is required.
         * @type {Array}
         */
        this.allowedRequiredValues = [];
        this.ignoreProperty = false;
        this.createJsonSchema();
    }
    /**
     *
     * @returns {Type<any>}
     */
    get type() {
        return this._type;
    }
    /**
     *
     * @param value
     */
    set type(value) {
        this._type = value || Object;
        this.createJsonSchema();
    }
    /**
     *
     * @returns {JsonSchema}
     */
    get schema() {
        return this.store.get("schema");
    }
    /**
     * Return the required state.
     * @returns {boolean}
     */
    get required() {
        return JsonSchemesRegistry_1.JsonSchemesRegistry.required(this.target, this.name || this.propertyKey);
    }
    /**
     * Change the state of the required data.
     * @param value
     */
    set required(value) {
        JsonSchemesRegistry_1.JsonSchemesRegistry.required(this.target, this.name || this.propertyKey, value);
    }
    /**
     *
     * @param target
     * @param propertyKey
     * @returns {PropertyMetadata}
     */
    static get(target, propertyKey) {
        const properties = this.getOwnProperties(target);
        if (!properties.has(propertyKey)) {
            this.set(target, propertyKey, new PropertyMetadata(target, propertyKey));
        }
        return properties.get(propertyKey);
    }
    /**
     *
     * @param target
     * @param options
     * @returns {Array}
     */
    static getProperties(target, options = {}) {
        const map = new Map();
        const ignored = [];
        core_1.ancestorsOf(target).forEach((klass) => {
            this.getOwnProperties(klass).forEach((v, k) => {
                /* istanbul ignore next */
                if (ignored.indexOf(k) !== -1) {
                    return;
                }
                if (options.withIgnoredProps) {
                    map.set(k, v);
                }
                else {
                    if (!v.ignoreProperty) {
                        map.set(k, v);
                    }
                    else {
                        map.delete(k);
                        ignored.push(k);
                    }
                }
            });
        });
        return map;
    }
    /**
     *
     * @param {Type<any>} target
     * @returns {Map<string | symbol, PropertyMetadata>}
     */
    static getOwnProperties(target) {
        const store = core_1.Store.from(target);
        if (!store.has("properties")) {
            store.set("properties", new Map());
        }
        return store.get("properties");
    }
    /**
     *
     * @param target
     * @param propertyKey
     * @param property
     */
    static set(target, propertyKey, property) {
        const properties = this.getOwnProperties(target);
        properties.set(propertyKey, property);
    }
    /**
     * Check precondition between value, required and allowedRequiredValues to know if the entity is required.
     * @param value
     * @returns {boolean}
     */
    isRequired(value) {
        return this.required && [undefined, null, ""].includes(value) && !this.allowedRequiredValues.includes(value);
    }
    createJsonSchema() {
        this.store.set("schema", JsonSchemesRegistry_1.JsonSchemesRegistry.property(this.target, this.propertyKey, this.type, this.collectionType));
    }
}
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Array)
], PropertyMetadata.prototype, "allowedRequiredValues", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Boolean)
], PropertyMetadata.prototype, "ignoreProperty", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Function)
], PropertyMetadata.prototype, "onSerialize", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Function)
], PropertyMetadata.prototype, "onDeserialize", void 0);
exports.PropertyMetadata = PropertyMetadata;
//# sourceMappingURL=PropertyMetadata.js.map