"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointMetadata = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const ParamMetadata_1 = require("./ParamMetadata");
/**
 * EndpointMetadata contains metadata about a controller and his method.
 * Each annotation (@Get, @Body...) attached to a method are stored in a endpoint.
 * EndpointMetadata convert this metadata to an array which contain arguments to call an Express method.
 *
 * Example :
 *
 *    @Controller("/my-path")
 *    provide MyClass {
 *
 *        @Get("/")
 *        @Authenticated()
 *        public myMethod(){}
 *    }
 *
 */
class EndpointMetadata extends core_1.Storable {
    constructor(options) {
        super(options.target, options.propertyKey, options.descriptor || Object.getOwnPropertyDescriptor(options.target, options.propertyKey));
        // LIFECYCLE
        this.beforeMiddlewares = [];
        this.middlewares = [];
        this.afterMiddlewares = [];
        /**
         * Route strategy.
         */
        this.pathsMethods = [];
        this.responses = new Map();
        this.statusCode = 200;
        const { target, statusCode, responses, propertyKey, beforeMiddlewares = [], middlewares = [], afterMiddlewares = [], pathsMethods = [], type } = options;
        this.provide = target;
        this._type = core_1.Metadata.getReturnType(target, propertyKey);
        this.after(afterMiddlewares);
        this.before(beforeMiddlewares);
        this.use(middlewares);
        this.pathsMethods = pathsMethods;
        this.type = type;
        statusCode && (this.statusCode = statusCode);
        if (responses) {
            this.responses = responses;
        }
        else {
            this.responses.set(this.statusCode, {
                code: this.statusCode
            });
        }
    }
    get type() {
        return core_1.isPromise(this._type) || core_1.isArrayOrArrayClass(this._type) || this._type === Object ? undefined : this._type;
    }
    set type(type) {
        this._type = type;
    }
    get targetName() {
        return core_1.nameOf(this.provide);
    }
    get params() {
        return ParamMetadata_1.ParamMetadata.getParams(this.target, this.propertyKey);
    }
    get response() {
        return this.responses.get(this.statusCode);
    }
    get view() {
        return this.store.get("view");
    }
    set view(view) {
        this.store.set("view", view);
    }
    get location() {
        return this.store.get("location");
    }
    set location(url) {
        this.store.set("location", url);
    }
    get redirect() {
        return this.store.get("redirect");
    }
    set redirect(options) {
        this.store.set("redirect", {
            status: 302,
            ...options
        });
    }
    /**
     * @deprecated Will be removed in v6
     */
    get contentType() {
        return this.store.get("contentType");
    }
    /**
     * @deprecated Will be removed in v6
     */
    set contentType(url) {
        this.store.set("contentType", url);
    }
    /**
     * Get all endpoints from a given class and his parents.
     * @param {Type<any>} target
     * @returns {EndpointMetadata[]}
     */
    static getEndpoints(target) {
        const map = new Map();
        const set = (base) => {
            const store = core_1.Store.from(base);
            if (store.has("endpoints")) {
                store.get("endpoints").forEach((endpoint) => {
                    if (!map.has(endpoint.propertyKey)) {
                        endpoint = endpoint.clone();
                        endpoint.provide = target;
                        map.set(endpoint.propertyKey, endpoint);
                    }
                });
            }
        };
        core_1.ancestorsOf(target).reverse().forEach(set);
        return Array.from(map.values());
    }
    /**
     * Get an endpoint.
     * @param target
     * @param propertyKey
     * @param descriptor
     */
    static get(target, propertyKey, descriptor) {
        descriptor = descriptor === undefined ? core_1.descriptorOf(core_1.prototypeOf(target), "test") : descriptor;
        const store = core_1.Store.from(target);
        const endpoints = store.get("endpoints") || new Map();
        store.set("endpoints", endpoints);
        if (!endpoints.has(propertyKey)) {
            endpoints.set(propertyKey, new EndpointMetadata({ target, propertyKey, descriptor }));
        }
        return store.get("endpoints").get(propertyKey);
    }
    /**
     * Gets a value indicating whether the target object or its prototype chain has already method registered.
     * @param target
     * @param method
     * @deprecated
     */
    /* istanbul ignore next */
    static has(target, method) {
        return core_1.Store.from(target).get("endpoints").has(method);
    }
    /**
     * Append mvc in the pool (before).
     * @param target
     * @param targetKey
     * @param args
     * @deprecated
     */
    /* istanbul ignore next */
    static useBefore(target, targetKey, args) {
        this.get(target, targetKey, core_1.descriptorOf(target, targetKey)).before(args);
        return this;
    }
    /**
     * Add middleware and configuration for the endpoint.
     * @param target
     * @param targetKey
     * @param args
     * @returns {Endpoint}
     * @deprecated
     */
    /* istanbul ignore next */
    static use(target, targetKey, args) {
        this.get(target, targetKey, core_1.descriptorOf(target, targetKey)).use(args);
        return this;
    }
    /**
     * Append mvc in the pool (after).
     * @param target
     * @param targetKey
     * @param args
     * @deprecated
     */
    /* istanbul ignore next */
    static useAfter(target, targetKey, args) {
        this.get(target, targetKey, core_1.descriptorOf(target, targetKey)).after(args);
        return this;
    }
    /**
     * Find the a value at the controller level. Let this value be extended or overridden by the endpoint itself.
     *
     * @param key
     * @returns {any}
     */
    get(key) {
        const ctrlValue = core_1.Store.from(this.target).get(key);
        let meta = core_1.deepExtends(undefined, ctrlValue);
        const endpointValue = this.store.get(key);
        if (endpointValue !== undefined) {
            meta = core_1.deepExtends(meta, endpointValue);
        }
        return meta;
    }
    /**
     * Change the type and the collection type from the status code.
     * @param {string | number} code
     * @deprecated Use endpoint.responses.get(code)
     */
    statusResponse(code) {
        if (code && this.responses.has(+code)) {
            const { type, collectionType } = this.responses.get(+code);
            this.type = type;
            this.collectionType = collectionType;
        }
        else {
            const { type, collectionType } = this.responses.get(this.statusCode) || {};
            this.type = type;
            this.collectionType = collectionType;
        }
        return this.responses.get(+code) || {};
    }
    /**
     *
     * @param args
     * @returns {EndpointMetadata}
     */
    before(args) {
        this.beforeMiddlewares = this.beforeMiddlewares.concat(args).filter(core_1.isFunction);
        return this;
    }
    /**
     *
     * @param args
     * @returns {EndpointMetadata}
     */
    after(args) {
        this.afterMiddlewares = this.afterMiddlewares.concat(args).filter(core_1.isFunction);
        return this;
    }
    /**
     * Store all arguments collected via Annotation.
     * @param args
     */
    use(args) {
        this.middlewares = this.middlewares.concat(args).filter(core_1.isFunction);
        return this;
    }
    /**
     * Store all arguments collected via Annotation.
     * @param args
     * @deprecated
     */
    /* istanbul ignore next */
    merge(args) {
        return this.use(args);
    }
    clone() {
        return new EndpointMetadata({
            target: this.target,
            propertyKey: this.propertyKey,
            descriptor: this.descriptor,
            beforeMiddlewares: this.beforeMiddlewares,
            middlewares: this.middlewares,
            afterMiddlewares: this.afterMiddlewares,
            pathsMethods: this.pathsMethods,
            type: this.type,
            responses: this.responses,
            statusCode: this.statusCode
        });
    }
}
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Array)
], EndpointMetadata.prototype, "beforeMiddlewares", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Array)
], EndpointMetadata.prototype, "middlewares", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Array)
], EndpointMetadata.prototype, "afterMiddlewares", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Array)
], EndpointMetadata.prototype, "pathsMethods", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Map)
], EndpointMetadata.prototype, "responses", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Number)
], EndpointMetadata.prototype, "statusCode", void 0);
exports.EndpointMetadata = EndpointMetadata;
//# sourceMappingURL=EndpointMetadata.js.map