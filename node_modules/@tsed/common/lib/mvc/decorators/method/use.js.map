{"version":3,"file":"use.js","sourceRoot":"","sources":["../../../../src/mvc/decorators/method/use.ts"],"names":[],"mappings":";;;AAAA,qCAAwE;AACxE,iDAAmD;AACnD,oEAA+D;AAE/D,SAAS,UAAU,CAAC,IAAW;IAC7B,IAAI,MAAM,GAAuB,SAAS,CAAC;IAC3C,IAAI,IAAI,GAAgC,SAAS,CAAC;IAElD,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,GAAQ,EAAE,EAAE;QAC3C,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,oBAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YACzD,MAAM,GAAG,GAAG,CAAC;YAEb,OAAO,KAAK,CAAC;SACd;QAED,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,YAAY,MAAM,EAAE;YACpD,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;YAEvB,OAAO,KAAK,CAAC;SACd;QAED,OAAO,CAAC,CAAC,GAAG,CAAC;IACf,CAAC,CAAC,CAAC;IAEH,OAAO;QACL,IAAI;QACJ,MAAM;QACN,WAAW;KACZ,CAAC;AACJ,CAAC;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,SAAgB,GAAG,CAAC,GAAG,IAAW;IAChC,OAAO,CAAI,MAAiB,EAAE,SAAkB,EAAE,UAAuC,EAAqC,EAAE;QAC9H,IAAI,sBAAe,CAAC,CAAC,MAAM,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC,KAAK,qBAAc,CAAC,MAAM,EAAE;YAC9E,MAAM,OAAO,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;YACjC,MAAM,QAAQ,GAAG,mCAAgB,CAAC,GAAG,CAAC,MAAM,EAAE,SAAU,CAAC,CAAC;YAE1D,OAAO,CAAC,IAAI;gBACV,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC;oBACzB,MAAM,EAAE,OAAO,CAAC,MAAM;oBACtB,IAAI,EAAE,OAAO,CAAC,IAAK;iBACpB,CAAC,CAAC;YAEL,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAEnB,OAAO,UAAU,CAAC;SACnB;QAED,YAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,aAAa,EAAE;YACtC,GAAG,EAAE,IAAI;SACV,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AArBD,kBAqBC","sourcesContent":["import {decoratorTypeOf, DecoratorTypes, Store, Type} from \"@tsed/core\";\nimport {HTTP_METHODS} from \"../../constants/index\";\nimport {EndpointMetadata} from \"../../models/EndpointMetadata\";\n\nfunction mapOptions(args: any[]) {\n  let method: string | undefined = undefined;\n  let path: string | RegExp | undefined = undefined;\n\n  const middlewares = args.filter((arg: any) => {\n    if (typeof arg === \"string\" && HTTP_METHODS.includes(arg)) {\n      method = arg;\n\n      return false;\n    }\n\n    if (typeof arg === \"string\" || arg instanceof RegExp) {\n      path = arg ? arg : \"/\";\n\n      return false;\n    }\n\n    return !!arg;\n  });\n\n  return {\n    path,\n    method,\n    middlewares\n  };\n}\n\n/**\n * Mounts the specified middleware function or functions at the specified path: the middleware function is executed when\n * the base of the requested path matches `path.\n *\n * ```typescript\n * @Controller('/')\n * @Use(Middleware1)\n * export class Ctrl {\n *\n *    @Get('/')\n *    @Use(Middleware2)\n *    get() { }\n * }\n *\n * ```\n *\n * @returns {Function}\n * @param args\n * @decorator\n * @operation\n */\nexport function Use(...args: any[]): Function {\n  return <T>(target: Type<any>, targetKey?: string, descriptor?: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> | void => {\n    if (decoratorTypeOf([target, targetKey, descriptor]) === DecoratorTypes.METHOD) {\n      const options = mapOptions(args);\n      const endpoint = EndpointMetadata.get(target, targetKey!);\n\n      options.path &&\n        endpoint.pathsMethods.push({\n          method: options.method,\n          path: options.path!\n        });\n\n      endpoint.use(args);\n\n      return descriptor;\n    }\n\n    Store.from(target).merge(\"middlewares\", {\n      use: args\n    });\n  };\n}\n"]}