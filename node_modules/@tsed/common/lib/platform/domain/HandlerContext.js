"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerContext = void 0;
const core_1 = require("@tsed/core");
const rxjs_1 = require("rxjs");
const abort_1 = require("../constants/abort");
const isFinish = (request, response) => {
    if (!response || !request) {
        return true;
    }
    return request.aborted || response.headersSent || response.writableEnded || response.writableFinished;
};
function isResponse(obj) {
    return obj.data && obj.headers && obj.status && obj.statusText;
}
class HandlerContext {
    constructor({ injector, request, response, next, err, metadata, args }) {
        this._isDone = false;
        this.injector = injector;
        this.request = request;
        this.response = response;
        this._next = next;
        this.err = err;
        this.metadata = metadata;
        this.args = args || [];
        this.next = this.next.bind(this);
    }
    get isDone() {
        const { response, request } = this;
        // @ts-ignore
        if (!this._isDone && isFinish(request, response)) {
            this.destroy();
        }
        return this._isDone;
    }
    get ctx() {
        var _a;
        return (_a = this.request) === null || _a === void 0 ? void 0 : _a.$ctx;
    }
    get container() {
        var _a, _b;
        return (_b = (_a = this.request) === null || _a === void 0 ? void 0 : _a.$ctx) === null || _b === void 0 ? void 0 : _b.container;
    }
    done(error, result) {
        if (this.isDone) {
            return;
        }
        const { metadata: { hasNextFunction }, ctx } = this;
        if (error) {
            return this.next(error);
        }
        if (!hasNextFunction) {
            if (!result !== undefined) {
                ctx.data = result;
            }
            this.next();
        }
    }
    handle(process) {
        if (this.isDone) {
            return;
        }
        const { metadata: { hasNextFunction }, request, response, next } = this;
        if (process) {
            if (process === response || process === abort_1.ABORT) {
                // ABANDON
                this.destroy();
                return;
            }
            if (rxjs_1.isObservable(process)) {
                process = process.toPromise();
            }
            if (isResponse(process)) {
                response.set(process.headers);
                response.status(process.status);
                return this.handle(process.data);
            }
            if (core_1.isStream(process) || Buffer.isBuffer(process)) {
                return this.done(null, process);
            }
            if (core_1.isFunction(process)) {
                // when process return a middleware
                return process(request, response, next.bind(this));
            }
            if (core_1.isPromise(process)) {
                return process.then((result) => this.handle(result)).catch((error) => this.done(error));
            }
        }
        if (!hasNextFunction) {
            // no next function and empty response
            this.done(null, process);
        }
    }
    /**
     *
     */
    async callHandler() {
        if (this.isDone) {
            return;
        }
        const { token, propertyKey } = this.metadata;
        const instance = this.injector.invoke(token, this.container);
        const handler = instance[propertyKey].bind(instance);
        await this.handle(handler(...this.args));
    }
    next(error) {
        const { _next: next } = this;
        this.destroy();
        return next && next(error);
    }
    destroy() {
        // @ts-ignore
        delete this.request;
        // @ts-ignore
        delete this.response;
        // @ts-ignore
        delete this.args;
        // @ts-ignore
        delete this._next;
        // @ts-ignore
        delete this.metadata;
        // @ts-ignore
        delete this.injector;
        // @ts-ignore
        delete this.err;
        this._isDone = true;
    }
}
exports.HandlerContext = HandlerContext;
//# sourceMappingURL=HandlerContext.js.map