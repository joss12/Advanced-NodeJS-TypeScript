"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformHandler = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const mvc_1 = require("../../mvc");
const ValidationError_1 = require("../../mvc/errors/ValidationError");
const HandlerContext_1 = require("../domain/HandlerContext");
const ParamValidationError_1 = require("../errors/ParamValidationError");
const UnknownFilterError_1 = require("../errors/UnknownFilterError");
/**
 * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).
 * @platform
 */
let PlatformHandler = class PlatformHandler {
    constructor(injector) {
        this.injector = injector;
    }
    createHandlerMetadata(obj) {
        const { injector } = this;
        let options;
        if (obj instanceof mvc_1.EndpointMetadata) {
            const provider = injector.getProvider(obj.provide);
            options = {
                token: provider.provide,
                target: provider.useClass,
                type: mvc_1.HandlerType.CONTROLLER,
                propertyKey: obj.propertyKey
            };
        }
        else {
            const provider = injector.getProvider(obj);
            if (provider) {
                options = {
                    token: provider.provide,
                    target: provider.useClass,
                    type: mvc_1.HandlerType.MIDDLEWARE,
                    propertyKey: "use"
                };
            }
            else {
                options = {
                    target: obj,
                    type: mvc_1.HandlerType.FUNCTION
                };
            }
        }
        return new mvc_1.HandlerMetadata(options);
    }
    /**
     * Create a native middleware based on the given metadata and return an instance of HandlerContext
     * @param metadata
     */
    createHandler(metadata) {
        if (!(metadata instanceof mvc_1.HandlerMetadata)) {
            metadata = this.createHandlerMetadata(metadata);
        }
        if (metadata.type === mvc_1.HandlerType.FUNCTION) {
            return metadata.handler;
        }
        this.sortPipes(metadata);
        return this.createRawHandler(metadata);
    }
    /**
     * Get param from the context
     * @param param
     * @param context
     */
    getParam(param, context) {
        const { ctx, ctx: { request, response } } = context;
        switch (param.paramType) {
            case mvc_1.ParamTypes.FORM_DATA:
                return context.request;
            case mvc_1.ParamTypes.RESPONSE:
                return context.response;
            case mvc_1.ParamTypes.REQUEST:
                return context.request;
            case mvc_1.ParamTypes.NEXT_FN:
                return context.next;
            case mvc_1.ParamTypes.ERR:
                return context.err;
            case mvc_1.ParamTypes.CONTEXT:
                return ctx;
            case mvc_1.ParamTypes.ENDPOINT_INFO:
                return ctx.endpoint;
            case mvc_1.ParamTypes.RESPONSE_DATA:
                return ctx.data;
            case mvc_1.ParamTypes.BODY:
                return request.body;
            case mvc_1.ParamTypes.QUERY:
                return request.query;
            case mvc_1.ParamTypes.PATH:
                return request.params;
            case mvc_1.ParamTypes.HEADER:
                return request.headers;
            case mvc_1.ParamTypes.COOKIES:
                return request.cookies;
            case mvc_1.ParamTypes.SESSION:
                return request.session;
            case mvc_1.ParamTypes.LOCALS:
                return response.locals;
            default:
                if (param.filter) {
                    return this.getFilter(param, context);
                }
                return context.request;
        }
    }
    /**
     * Return a custom filter
     * @param param
     * @param context
     * @deprecated
     */
    getFilter(param, context) {
        const { expression } = param;
        const instance = this.injector.get(param.filter);
        if (!instance || !instance.transform) {
            throw new UnknownFilterError_1.UnknownFilterError(param.filter);
        }
        return instance.transform(expression, context.request, context.response);
    }
    mapHandlerContext(metadata, { request, response, err, next }) {
        return new HandlerContext_1.HandlerContext({
            injector: this.injector,
            request,
            response,
            next,
            err,
            metadata,
            args: []
        });
    }
    createRawHandler(metadata) {
        if (metadata.hasErrorParam) {
            return (err, request, response, next) => this.onRequest(this.mapHandlerContext(metadata, {
                request,
                response,
                next,
                err
            }));
        }
        else {
            return (request, response, next) => this.onRequest(this.mapHandlerContext(metadata, { request, response, next }));
        }
    }
    async onRequest(context) {
        if (context.isDone) {
            return;
        }
        const { metadata: { parameters } } = context;
        try {
            context.args = await Promise.all(parameters.map((param) => this.mapParam(param, context)));
            await context.callHandler();
        }
        catch (error) {
            context.next(error);
        }
    }
    sortPipes(metadata) {
        const get = (pipe) => {
            return this.injector.getProvider(pipe).priority || 0;
        };
        metadata.parameters.forEach((param) => {
            return (param.pipes = param.pipes.sort((p1, p2) => {
                return get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0;
            }));
        });
    }
    /**
     *
     * @param metadata
     * @param context
     */
    async mapParam(metadata, context) {
        const { injector } = context;
        const value = this.getParam(metadata, context);
        // istanbul ignore next
        const handleError = async (cb) => {
            try {
                return await cb();
            }
            catch (er) {
                throw er instanceof ValidationError_1.ValidationError ? ParamValidationError_1.ParamValidationError.from(metadata, er) : er;
            }
        };
        return metadata.pipes.reduce(async (value, pipe) => {
            value = await value;
            return handleError(() => injector.get(pipe).transform(value, metadata));
        }, value);
    }
};
PlatformHandler = tslib_1.__decorate([
    di_1.Injectable({
        scope: di_1.ProviderScope.SINGLETON
    }),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService])
], PlatformHandler);
exports.PlatformHandler = PlatformHandler;
//# sourceMappingURL=PlatformHandler.js.map