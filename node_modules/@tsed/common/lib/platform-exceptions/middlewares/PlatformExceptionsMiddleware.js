"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformExceptionsMiddleware = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const middleware_1 = require("../../mvc/decorators/class/middleware");
const error_1 = require("../../mvc/decorators/params/error");
const context_1 = require("../../platform/decorators/context");
const ExceptionTypesContainer_1 = require("../domain/ExceptionTypesContainer");
const GlobalErrorHandlerMiddleware_1 = require("./GlobalErrorHandlerMiddleware");
/**
 * Catch all errors and return the json error with the right status code when it's possible.
 * @middleware
 * @platform
 */
let PlatformExceptionsMiddleware = class PlatformExceptionsMiddleware {
    constructor() {
        this.types = ExceptionTypesContainer_1.getExceptionTypes();
    }
    use(error, ctx) {
        const target = core_1.ancestorsOf(error)
            .reverse()
            .find((target) => this.types.has(target));
        if (target) {
            return this.types.get(target).catch(error, ctx);
        }
        throw error;
    }
};
tslib_1.__decorate([
    di_1.Inject(),
    tslib_1.__metadata("design:type", GlobalErrorHandlerMiddleware_1.GlobalErrorHandlerMiddleware)
], PlatformExceptionsMiddleware.prototype, "middleware", void 0);
tslib_1.__decorate([
    tslib_1.__param(0, error_1.Err()), tslib_1.__param(1, context_1.Context()),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Object)
], PlatformExceptionsMiddleware.prototype, "use", null);
PlatformExceptionsMiddleware = tslib_1.__decorate([
    middleware_1.Middleware()
], PlatformExceptionsMiddleware);
exports.PlatformExceptionsMiddleware = PlatformExceptionsMiddleware;
//# sourceMappingURL=PlatformExceptionsMiddleware.js.map